// WARNING: DO NOT EDIT THIS FILE. THIS FILE IS MANAGED BY SPRING ROO.
// You may push code into the target .java compilation unit if you wish to edit any member(s).

package org.adorsys.geshotel.resto.domain;

import java.lang.String;
import java.util.Date;
import javax.persistence.EntityManager;
import javax.persistence.TypedQuery;
import org.adorsys.geshotel.booking.domain.Invoice;
import org.adorsys.geshotel.domain.Customer;
import org.adorsys.geshotel.resto.domain.BarRestauState;
import org.adorsys.geshotel.resto.domain.CustomerType;
import org.adorsys.geshotel.resto.domain.Sale;

privileged aspect Sale_Roo_Finder {
    
    public static TypedQuery<Sale> Sale.findSalesByCustomer(Customer customer) {
        if (customer == null) throw new IllegalArgumentException("The customer argument is required");
        EntityManager em = Sale.entityManager();
        TypedQuery<Sale> q = em.createQuery("SELECT o FROM Sale AS o WHERE o.customer = :customer", Sale.class);
        q.setParameter("customer", customer);
        return q;
    }
    
    public static TypedQuery<Sale> Sale.findSalesByCustomerAndInvoice(Customer customer, Invoice invoice) {
        if (customer == null) throw new IllegalArgumentException("The customer argument is required");
        if (invoice == null) throw new IllegalArgumentException("The invoice argument is required");
        EntityManager em = Sale.entityManager();
        TypedQuery<Sale> q = em.createQuery("SELECT o FROM Sale AS o WHERE o.customer = :customer AND o.invoice = :invoice", Sale.class);
        q.setParameter("customer", customer);
        q.setParameter("invoice", invoice);
        return q;
    }
    
    public static TypedQuery<Sale> Sale.findSalesByInvoice(Invoice invoice) {
        if (invoice == null) throw new IllegalArgumentException("The invoice argument is required");
        EntityManager em = Sale.entityManager();
        TypedQuery<Sale> q = em.createQuery("SELECT o FROM Sale AS o WHERE o.invoice = :invoice", Sale.class);
        q.setParameter("invoice", invoice);
        return q;
    }
    
    public static TypedQuery<Sale> Sale.findSalesByRecordDateBetweenAndSaleState(Date minRecordDate, Date maxRecordDate, BarRestauState saleState) {
        if (minRecordDate == null) throw new IllegalArgumentException("The minRecordDate argument is required");
        if (maxRecordDate == null) throw new IllegalArgumentException("The maxRecordDate argument is required");
        if (saleState == null) throw new IllegalArgumentException("The saleState argument is required");
        EntityManager em = Sale.entityManager();
        TypedQuery<Sale> q = em.createQuery("SELECT o FROM Sale AS o WHERE o.recordDate BETWEEN :minRecordDate AND :maxRecordDate  AND o.saleState = :saleState", Sale.class);
        q.setParameter("minRecordDate", minRecordDate);
        q.setParameter("maxRecordDate", maxRecordDate);
        q.setParameter("saleState", saleState);
        return q;
    }
    
    public static TypedQuery<Sale> Sale.findSalesByRecordDateBetweenAndSaleStateAndCustomerType(Date minRecordDate, Date maxRecordDate, BarRestauState saleState, CustomerType customerType) {
        if (minRecordDate == null) throw new IllegalArgumentException("The minRecordDate argument is required");
        if (maxRecordDate == null) throw new IllegalArgumentException("The maxRecordDate argument is required");
        if (saleState == null) throw new IllegalArgumentException("The saleState argument is required");
        if (customerType == null) throw new IllegalArgumentException("The customerType argument is required");
        EntityManager em = Sale.entityManager();
        TypedQuery<Sale> q = em.createQuery("SELECT o FROM Sale AS o WHERE o.recordDate BETWEEN :minRecordDate AND :maxRecordDate  AND o.saleState = :saleState AND o.customerType = :customerType", Sale.class);
        q.setParameter("minRecordDate", minRecordDate);
        q.setParameter("maxRecordDate", maxRecordDate);
        q.setParameter("saleState", saleState);
        q.setParameter("customerType", customerType);
        return q;
    }
    
    public static TypedQuery<Sale> Sale.findSalesBySaleKeyEquals(String saleKey) {
        if (saleKey == null || saleKey.length() == 0) throw new IllegalArgumentException("The saleKey argument is required");
        EntityManager em = Sale.entityManager();
        TypedQuery<Sale> q = em.createQuery("SELECT o FROM Sale AS o WHERE o.saleKey = :saleKey", Sale.class);
        q.setParameter("saleKey", saleKey);
        return q;
    }
    
    public static TypedQuery<Sale> Sale.findSalesBySaleState(BarRestauState saleState) {
        if (saleState == null) throw new IllegalArgumentException("The saleState argument is required");
        EntityManager em = Sale.entityManager();
        TypedQuery<Sale> q = em.createQuery("SELECT o FROM Sale AS o WHERE o.saleState = :saleState", Sale.class);
        q.setParameter("saleState", saleState);
        return q;
    }
    
    public static TypedQuery<Sale> Sale.findSalesBySaleStateAndRecordDateBetween(BarRestauState saleState, Date minRecordDate, Date maxRecordDate) {
        if (saleState == null) throw new IllegalArgumentException("The saleState argument is required");
        if (minRecordDate == null) throw new IllegalArgumentException("The minRecordDate argument is required");
        if (maxRecordDate == null) throw new IllegalArgumentException("The maxRecordDate argument is required");
        EntityManager em = Sale.entityManager();
        TypedQuery<Sale> q = em.createQuery("SELECT o FROM Sale AS o WHERE o.saleState = :saleState AND o.recordDate BETWEEN :minRecordDate AND :maxRecordDate", Sale.class);
        q.setParameter("saleState", saleState);
        q.setParameter("minRecordDate", minRecordDate);
        q.setParameter("maxRecordDate", maxRecordDate);
        return q;
    }
    
}
